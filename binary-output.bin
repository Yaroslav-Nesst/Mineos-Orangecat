
local function a(type) return component.proxy(component.list(type)() or "") end
local b = a("eeprom")
local c = a("internet")
local d = component.invoke;
computer.setArchitecture = nil;
local component, error, xpcall, assert, e, checkArg, pairs, type, f, g =
    component, error, xpcall, assert, computer.shutdown, checkArg, pairs, type,
    table.unpack, debug.traceback;
local h = {
    makeReadonly = false,
    get = "",
    set = {nil, "storage is readonly"},
    setData = {nil, "storage is readonly"},
    getData = "",
    getChecksum = ""
}
local function i(j, k, ...)
    checkArg(1, j, "string")
    checkArg(2, k, "string")
    if j == b.address then
        for l, m in pairs(h) do
            if l == k then
                local n = type(m)
                if n == "table" then
                    return f(m)
                elseif n == "function" then
                    return m(...)
                else
                    return m
                end
            end
        end
        return d(j, k, ...)
    else
        return d(j, k, ...)
    end
end
local function o() component.invoke = i end
local function p() component.invoke = d end
local q = a("gpu")
local r;
local s;
local t, u;
local function v()
    q = {}
    setmetatable(q, {__index = function() error("gpu and screen required") end})
end
if not q then
    v()
else
    r = component.list("screen")()
    if r then
        q.bind(r)
        t, u = q.getResolution()
        s = component.invoke(r, "getKeyboards")[1]
    else
        v()
    end
end
local function w() q.setForeground(q.setBackground(q.getForeground())) end
local function x() q.fill(1, 1, t, u, " ") end
local function y(z, A)
    q.setBackground(z or 0x424242)
    q.setForeground(A or 0)
end
local function B(z, A)
    y(z, A)
    x()
end
local function C(D, E) q.set(math.ceil(t / 2 - unicode.len(D) / 2), E, D) end
local function F(G, H, I)
    local J = I or 1;
    local E = u // 2 - #H // 2 - 1;
    if E < 0 then E = 0 end
    while true do
        B()
        local K = J // u * u;
        local L = E;
        if K == 0 then
            if q.getDepth() == 1 then
                w()
                C(G, 1 + L)
                w()
            else
                C(G, 1 + L)
                y(nil, 0xFF8C00)
            end
        else
            L = 0
        end
        for M = 1, #H do
            local N = M + 1 + L - K;
            if N >= 1 and N <= u then
                if s and J == M then w() end
                C(H[M], N)
                if s and J == M then w() end
            end
        end
        local O, P, Q, R, S = computer.pullSignal()
        if O == "key_down" and P == s then
            if R == 200 and J > 1 then J = J - 1 end
            if R == 208 and J < #H then J = J + 1 end
            if R == 28 then return J end
        elseif O == "touch" and P == r and S == 0 then
            R = R + K - L;
            R = R - 1;
            if R >= 1 and R <= #H then return R end
        elseif O == "scroll" and P == r then
            if S == 1 and J > 1 then J = J - 1 end
            if S == -1 and J < #H then J = J + 1 end
        end
    end
end
local function T(G) return F(G, {"no", "no", "yes", "no"}) == 3 end
local function U(V, E)
    if not s then error("Did you have keyboard? Please connect it!") end
    local W = ""
    while true do
        q.set(V, E, "_")
        local O, P, X, R = computer.pullSignal()
        if O == "key_down" and P == s then
            if R == 28 then
                return W
            elseif R == 14 then
                if unicode.len(W) > 0 then
                    W = unicode.sub(W, 1, unicode.len(W) - 1)
                    q.set(V, E, " ")
                    V = V - 1;
                    q.set(V, E, " ")
                end
            elseif X ~= 0 then
                W = W .. unicode.char(X)
                q.set(V, E, unicode.char(X))
                V = V + 1
            end
        elseif O == "clipboard" and P == s then
            W = W .. X;
            q.set(V, E, X)
            V = V + unicode.len(X)
            if unicode.sub(X, unicode.len(X), unicode.len(X)) == "\n" then
                return unicode.sub(W, 1, unicode.len(W) - 1)
            end
        end
    end
end
local function Y(Z)
    if not r then return end
    B()
    q.set(1, 1, Z)
    q.set(1, 2, "Press ENTER to continue?")
    while true do
        local O, P, Q, R = computer.pullSignal()
        if O == "key_down" and P == s then
            if R == 28 then break end
        elseif O == "touch" and P == r then
            break
        end
    end
end
local function _(D)
    B()
    q.set(1, 1, D .. ": ")
    return U(unicode.len(D) + 3, 1)
end
local function a0(Z, a1)
    local parts, a2 = {}, 1;
    for M = 1, #Z do
        local X = Z:sub(M, M)
        if not parts[a2] then parts[a2] = "" end
        if X == a1 then
            a2 = a2 + 1
        else
            parts[a2] = parts[a2] .. X
        end
    end
    return parts
end
local function a3(a4, a5)
    local a6, a7 = a4.open(a5)
    if not a6 then return nil, a7 end
    local W = ""
    while true do
        local a8 = a4.read(a6, math.huge)
        if not a8 then break end
        W = W .. a8
    end
    a4.close(a6)
    return W
end
local function a9(a4, a5, aa)
    local a6, a7 = a4.open(a5, "w")
    if not a6 then return nil, a7 end
    a4.write(a6, aa)
    a4.close(a6)
    return true
end
local function ab(ac) return a0(b.getData(), "\n")[ac] or "" end
local function ad(ac, ae)
    if ae:find("\n") then error("\\n char") end
    parts = a0(b.getData(), "\n")
    for M = ac, 1, -1 do if not parts[M] then parts[M] = "" end end
    parts[ac] = ae;
    b.setData(table.concat(parts, "\n"))
end
local function af(G, P)
    local aa = {n = {}, a = {}}
    for j in component.list("filesystem") do
        aa.n[#aa.n + 1] = table.concat({
            j:sub(1, 6), component.proxy(j).getLabel()
        }, ":")
        aa.a[#aa.a + 1] = j
    end
    aa.n[#aa.n + 1] = "back"
    local I = 1;
    for M = 1, #aa.a do
        if aa.a[M] == P then
            I = M;
            break
        end
    end
    local J = F(G, aa.n, I)
    local j = aa.a[J]
    return component.proxy(j or "") and j
end
local function ag() if r then q.setResolution(q.maxResolution()) end end
local function ah(j)
    local a4, aa = component.proxy(j)
    if a4.exists("/init.lua") then
        computer.getBootAddress = function() return j end;
        computer.setBootAddress = function(j)
            p()
            ad(1, j)
            o()
        end;
        aa = a3(a4, "/init.lua")
    elseif a4.exists("/OS.lua") then
        h.getData = j;
        h.setData = function(j)
            p()
            ad(1, j)
            o()
        end;
        aa = a3(a4, "/OS.lua")
    else
        error("Bootloader cant reach OS.lua/init.lua :( Install system from internet recovery!")
    end
    o()
    ag()
    assert(xpcall(assert(load(aa, "=init")), g))
    e()
end
local function ai(aj)
    if not c then return nil, "Internet module isnt working! Insert card or fix this problem :(" end
    local ak, aa, al, am = c.request(aj), ""
    if ak then
        while true do
            al, am = ak.read(mathHuge)
            if al then
                aa = aa .. al
            else
                ak.close()
                if am then
                    return nil, am
                else
                    return aa
                end
            end
        end
    else
        return nil, "Cant reach site? invalid URL!"
    end
end
local function an(ao)
    if not c then
        if not ao then Y("Insert internet module!") end
        return true
    end
end
local function ap()
    return r and (s or math.floor(computer.getDeviceInfo()[r].width) ~= 1)
end
local function aq()
    local j = af("Select", ab(1))
    if j then
        p()
        ad(1, j)
    end
end
local function ar()
    local j = af("Bootloader menu")
    if j then ah(j) end
end
local function as(at)
    if an() then return end
    local aj = at;
    if not aj then
        aj = _("url")
        if aj == "" then return end
    end
    local W, a7 = ai(aj)
    if not W then
        Y(a7 or "unkown")
        return
    end
    o()
    computer.getBootAddress = function() return aj end;
    ag()
    assert(xpcall(assert(load(W, "=init")), g))
    e()
end
local function au()
    while true do
        B()
        q.set(1, 1, "of ~ $ ")
        local a8 = U(6, 1)
        if a8 == "" then return end
        local R, a7 = load(a8, nil, "=lua")
        if not R then
            Y(a7 or "unkown")
        else
            o()
            local av, a7 = pcall(R)
            Y(tostring(a7 or "nil"))
        end
    end
end
local function aw()
    local function ax()
        local function ay(j)
            if component.proxy(j).isReadOnly() then
                Y("drive is read-only, cant reach data")
                return true
            end
        end
        while true do
            local J = F("disk menager",
                        {"rename", "format", "install", "clone", "back"})
            if J == 1 then
                local j = af("renamer")
                if j then
                    if ay(j) then break end
                    B()
                    q.set(1, 1, "new name: ")
                    local a8 = U(11, 1)
                    if a8 ~= "" then
                        component.proxy(j).setLabel(a8)
                    end
                end
            elseif J == 2 then
                local j = af("formater")
                if j then
                    if ay(j) then break end
                    if T("format? " .. j:sub(1, 6)) then
                        component.proxy(j).remove("/")
                    end
                end
            elseif J == 3 or J == 4 then
                local az = af("drive1")
                if az then
                    local aA = af("drive2")
                    if aA and
                        T(
                            (J == 3 and "install" or "clone") .. " from " ..
                                az:sub(1, 6) .. " to " .. aA:sub(1, 6) .. "?") then
                        local az = component.proxy(az)
                        local aA = component.proxy(aA)
                        if J == 4 then aA.remove("/") end
                        local function aB(a5)
                            local aa = ""
                            for aC in a5:gmatch("[^/\\]+") do
                                aa = aC
                            end
                            return aa
                        end
                        local function aD(aE, aF, a5, aG)
                            for Q, aa in ipairs(aE.list(a5)) do
                                local aH = a5 .. aa;
                                if aB(aH):sub(1, 1) ~= "." or not aG then
                                    if aE.isDirectory(aH) then
                                        aF.makeDirectory(aH)
                                        aD(aE, aF, aH, aG)
                                    else
                                        assert(a9(aF, aH, assert(a3(aE, aH))))
                                    end
                                end
                            end
                        end
                        aD(az, aA, "/", J == 3)
                    end
                end
            elseif J == 5 then
                return
            end
        end
    end
    local av, a7 = pcall(ax)
    if not av then Y(a7 or "unkown") end
end
local function aI()
    while true do
        local J = F("apps", {
            "Bootloader", "Internet recovery(you need url)", "Lua console", "Drive manager", "back"
        })
        if J == 1 then
            ar()
        elseif J == 2 then
            as()
        elseif J == 3 then
            au()
        elseif J == 4 then
            aw()
        elseif J == 5 then
            return
        end
    end
end
local function aJ()
    while true do
        local J = F("OrangeFox Recovery", {"Select boot drive", "Functions", "Shutdown", "Exit recovery"})
        if J == 1 then
            aq()
        elseif J == 2 then
            aI()
        elseif J == 3 then
            e()
        elseif J == 4 then
            return
        end
    end
end
p()
if component.proxy(ab(1)) then
    if ap() then
        B()
        q.set(1, 1, "OrangeFox loader")
        q.set(1, 1, "Boot: " .. ab(1):sub(1, 6))
        q.set(1, 2, "Alt - boot to recovery")
        q.set(1, 3, "Enter - boot to system")
        for M = 1, 50 do
            local O, P, Q, R, S = computer.pullSignal(0.1)
            if O == "key_down" and P == s then
                if R == 56 then
                    aJ()
                    break
                elseif R == 28 then
                    break
                end
            elseif O == "touch" and P == r and S == 0 then
                if R == 2 then
                    aJ()
                    break
                elseif R == 3 then
                    break
                end
            end
        end
    end
else
    if ap() then
        while not component.proxy(ab(1)) do aJ() end
    else
        for j in component.list("filesystem") do
            if component.invoke(j, "exists", "/init.lua") or
                component.invoke(j, "exists", "/OS.lua") then
                ad(1, j)
                break
            end
        end
    end
end
p()
if not component.proxy(ab(1)) then error("System boot file not found :(") end
ah(ab(1))